using Player;
using UGizmo;
using UnityEngine;
using Vector2 = UnityEngine.Vector2;
using Vector3 = UnityEngine.Vector3;

namespace PlayerV2
{
    [RequireComponent(typeof(PlayerInputHandler))]
    public class GameMovement : MonoBehaviour
    {
        [Tooltip("The Width(x) and Height(y) of your capsule")]
        public Vector2 bodySize = new(0.8f, 2f);

        [Tooltip(
            "Specifies a skin around the character within which contacts will be generated by the physics engine. Use it to avoid numerical precision issues.")]
        public float skinWidth = 0.008f;

        /// <summary>
        /// This will be used in case the skin is inside a wall, making sure there we have at least one skinWidth distance from any collisions.
        /// </summary>
        // private float SimBackStepCompensation
        // {
        //     [MethodImpl(MethodImplOptions.AggressiveInlining)]
        //     get => skinWidth * 2f;
        // }
        public LayerMask groundLayer;

        public float gravityForce = 0.35f;

        public Vector3 down = Vector3.down;

        public Vector3 velocity = Vector3.zero;

        private CollisionInfo _collisionInfo;

        private const bool PlayerPhysicsDebug = true;

        private void FixedUpdate()
        {
            // why is there a skin width https://chatgpt.com/share/26ad5379-b15d-4d69-82b4-e5a77b8eb873
            // https://lightbug14.gitbook.io/ccp/fundamentals/untitled/character-actor/stable-movement-features
            // https://docs.unity3d.com/Packages/com.unity.charactercontroller@1.1/manual/step-handling.html
            var dt = Time.fixedDeltaTime;
            var acceleration = Vector3.zero;

            velocity += acceleration * dt;
            transform.position = CollideAndSlide(transform.position, velocity);

            // if (PlayerPhysicsDebug)
            // {
            //     UGizmos.DrawWireCapsule(GetBottomHemisphere(transform.position), GetTopHemisphere(transform.position), Radius, Color.gray);
            //     UGizmos.DrawLine(transform.position, transform.position + velocity, Color.blue);
            // }


            // post update
        }

        private Vector3 CollideAndSlide(Vector3 pos, Vector3 vel)
        {
            var firstPlaneNormal = Vector3.negativeInfinity;
            var dest = pos + vel;
        
            for (var i = 0; i < 3; i++)
            {
                BodyCast(pos, vel);
            
                // no collisions
                if (!_collisionInfo.HasHit) return dest;
            
                pos += vel.normalized * _collisionInfo.ShortDistance;

                if (i == 0)
                {
                    // first plane hit
                    firstPlaneNormal = _collisionInfo.HitInfo.normal;
                    vel = Vector3.ProjectOnPlane(_collisionInfo.RemainderVelocity, _collisionInfo.HitInfo.normal);
                    dest = _collisionInfo.NearPoint + vel;

                    if (PlayerPhysicsDebug)
                    {
                        UGizmos.DrawPoint(dest, 0.01f, Color.blue);
                        UGizmos.DrawPoint(_collisionInfo.NearPoint, 0.01f, Color.green);
                        UGizmos.DrawLine(dest, _collisionInfo.NearPoint, Color.blue);
                        UGizmos.DrawWireCapsule(GetBottomHemisphere(_collisionInfo.NearPoint),
                            GetTopHemisphere(_collisionInfo.NearPoint), Radius, Color.gray);
                        UGizmos.DrawPoint(dest, 0.01f, Color.red);
                        UGizmos.DrawLine(pos, pos + vel, Color.red);
                    }
                }
                else if (i == 1)
                {
                    // second plane hit
                    var crease = Vector3.Cross(firstPlaneNormal, _collisionInfo.HitInfo.normal).normalized;
                    var signedDistance = Vector3.Dot(_collisionInfo.RemainderVelocity, crease);
                    vel = signedDistance * crease;
                    dest = pos + vel;
                }
            }
        
            return pos;
        }

        private void BodyCast(Vector3 position, Vector3 vel)
        {
            var bottom = GetBottomHemisphere(position);
            var top = GetTopHemisphere(position);
            var magnitude = vel.magnitude;
            var direction = vel / magnitude;

            var hasHit = Physics.CapsuleCast(bottom, top, Radius, direction, out var hitInfo,
                magnitude, groundLayer, QueryTriggerInteraction.UseGlobal);

            var shortDistance = Mathf.Max(hitInfo.distance - skinWidth, 0f);
            var remainingDistance = magnitude - shortDistance;

            if (PlayerPhysicsDebug)
            {
                UGizmos.DrawPoint(hitInfo.point, 0.03f, Color.red);
                UGizmos.DrawArrow(hitInfo.point, hitInfo.point + hitInfo.normal * 0.5f, Color.gray, 0.2f, 0.01f);
            }

            if (hasHit)
            {
                _collisionInfo.HasHit = true;
                _collisionInfo.HitInfo = hitInfo;
                _collisionInfo.ShortDistance = shortDistance;
                _collisionInfo.RemainderVelocity = direction * remainingDistance;
                _collisionInfo.NearPoint = position + direction * shortDistance;
            }
            else
            {
                _collisionInfo.HasHit = false;
            }
        }

        private void OnDrawGizmos() => DrawPlayerGizmos(Color.green);

        private void DrawPlayerGizmos(Color color)
        {
            Gizmos.color = color;
            var bottom = GetBottomHemisphere(transform.position);
            var top = GetTopHemisphere(transform.position);
            Gizmos.DrawWireSphere(bottom, Radius);
            Gizmos.DrawWireSphere(top, Radius);
            Gizmos.DrawLine(bottom + Vector3.forward * Radius, top + Vector3.forward * Radius);
            Gizmos.DrawLine(bottom + Vector3.back * Radius, top + Vector3.back * Radius);
            Gizmos.DrawLine(bottom + Vector3.right * Radius, top + Vector3.right * Radius);
            Gizmos.DrawLine(bottom + Vector3.left * Radius, top + Vector3.left * Radius);
        }

        private Vector3 GetBottomHemisphere(Vector3 position) => position + Radius * -down;
        private Vector3 GetTopHemisphere(Vector3 position) => position + -down * (bodySize.y - Radius);
        private float Radius => bodySize.x * 0.5f;
    }
}
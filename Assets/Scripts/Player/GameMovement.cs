using System;
using System.Runtime.CompilerServices;
using Input;
using UGizmo;
using Unity.VisualScripting.FullSerializer.Internal.Converters;
using UnityEngine;
using UnityEngine.Serialization;
using Vector2 = UnityEngine.Vector2;
using Vector3 = UnityEngine.Vector3;

namespace Player
{
    [RequireComponent(typeof(PlayerInputHandler))]
    public class GameMovement : MonoBehaviour
    {
        [Header("Collision")]
        public float height = 1.8f;

        public float radius = 0.8f;

        [Tooltip(
            "Specifies a skin around the character within which contacts will be generated by the physics engine. Use it to avoid numerical precision issues.")]
        public float skinWidth = 0.008f;

        public LayerMask groundLayer;

        [Header("Gravity")]
        public float gravityForce = 0.35f;

        public Vector3 down = Vector3.down;

        [Header("Movement")]
        public float movementForce = 1.3f;

        public float groundFriction = 10f;

        [Header("Debug")]
        public Vector3 velocity = Vector3.zero;

        public Vector3 verticalVelocity = Vector3.zero;
        public Vector3 velocityOverride = Vector3.zero;
        public bool useVelocityOverride = false;

        private CollisionInfo _collisionInfo;

        private const bool PlayerPhysicsDebug = true;
        private PlayerInputHandler _playerInputHandler;

        private void Awake()
        {
            _playerInputHandler = GetComponent<PlayerInputHandler>();
        }

        private void FixedUpdate()
        {
            // why is there a skin width https://chatgpt.com/share/26ad5379-b15d-4d69-82b4-e5a77b8eb873
            // https://lightbug14.gitbook.io/ccp/fundamentals/untitled/character-actor/stable-movement-features
            // https://docs.unity3d.com/Packages/com.unity.charactercontroller@1.1/manual/step-handling.html

            var dt = Time.fixedDeltaTime;
            var acceleration = Vector3.zero;

            // WASD movement
            acceleration += _playerInputHandler.RequestedMovementDirection * movementForce;

            // Ground friction
            acceleration -= velocity.normalized * (velocity.magnitude * groundFriction);

            // Apply Horizontal velocity
            velocity += acceleration * dt;
            if (useVelocityOverride)
            {
                velocity = velocityOverride;
            }

            transform.position = CollideAndSlide(transform.position, ref velocity);
            // Debug.Log(Vector3.Dot(down, _collisionInfo.HitInfo.normal) + " " + casIter);
            UGizmos.DrawWireCapsule(GetBottomHemisphere(transform.position), GetTopHemisphere(transform.position),
                Radius + skinWidth, Color.gray);
            UGizmos.DrawLine(transform.position, transform.position + velocity, Color.yellow);
        }

        private int casIter;

        private Vector3 CollideAndSlide(Vector3 pos, ref Vector3 vel)
        {
            var firstPlaneNormal = Vector3.zero;
            var dest = pos + vel;

            for (casIter = 0; casIter < 3; casIter++)
            {
                BodyCast(pos, vel);

                // no collisions
                if (!_collisionInfo.HasHit) return dest;

                pos += vel.normalized * _collisionInfo.ShortDistance;

                if (casIter == 0)
                {
                    // first plane hit
                    firstPlaneNormal = _collisionInfo.HitInfo.normal;
                    vel = Vector3.ProjectOnPlane(_collisionInfo.RemainderVelocity, _collisionInfo.HitInfo.normal);
                    dest = _collisionInfo.NearPoint + vel;
                    // dest is the bottom sphere, we need to get the closes point on the segment and use that sphere instead
                    // dest -= (PlaneDist(dest, firstPlaneNormal, _collisionInfo.HitInfo.point) - (Radius + skinWidth)) *
                    //         firstPlaneNormal;
                    // vel = dest - _collisionInfo.NearPoint;
                }
                else if (casIter == 1)
                {
                    // second plane hit
                    var crease = Vector3.Cross(firstPlaneNormal, _collisionInfo.HitInfo.normal).normalized;
                    var signedDistance = Vector3.Dot(_collisionInfo.RemainderVelocity, crease);
                    vel = signedDistance * crease;
                    dest = pos + vel;
                    UGizmos.DrawLine(pos, pos + vel, Color.blue);
                }
                else if (casIter == 2)
                {
                    vel = Vector3.zero;
                    pos = _collisionInfo.NearPoint;
                }
            }

            return pos;
        }

        private void BodyCast(Vector3 position, Vector3 vel)
        {
            var bottom = GetBottomHemisphere(position);
            var top = GetTopHemisphere(position);
            var magnitude = vel.magnitude;
            var direction = vel / magnitude;

            var hasHit = Physics.CapsuleCast(bottom, top, Radius, direction, out var hitInfo,
                magnitude + skinWidth, groundLayer, QueryTriggerInteraction.UseGlobal);


            if (PlayerPhysicsDebug)
            {
                UGizmos.DrawRay(hitInfo.point, hitInfo.normal, Color.red);
            }

            if (hasHit)
            {
                var touchVel = vel * hitInfo.distance / vel.magnitude;
                var n = hitInfo.normal;
                var adjustedSkinWidth = -(skinWidth * n.sqrMagnitude * vel.magnitude) / Vector3.Dot(n, touchVel);
                var shortDistance = Mathf.Max(hitInfo.distance - adjustedSkinWidth, 0f);
                var remainingDistance = magnitude - shortDistance;

                _collisionInfo.HasHit = true;
                _collisionInfo.HitInfo = hitInfo;
                _collisionInfo.ShortDistance = shortDistance;
                _collisionInfo.RemainderVelocity = direction * remainingDistance;
                _collisionInfo.NearPoint = position + direction * shortDistance;
                _collisionInfo.RelevantOffset = ClosestPointOffset(position, hitInfo.point);

                var color = casIter switch
                {
                    0 => Color.blue,
                    1 => Color.green,
                    _ => Color.red
                };
                // UGizmos.DrawWireCapsule(bottom, top, Radius, color);
                var hitPos = position + direction * hitInfo.distance;
                var bottomNew = GetBottomHemisphere(hitPos);
                var topNew = GetTopHemisphere(hitPos);
                UGizmos.DrawWireCapsule(bottomNew, topNew, Radius, color);
                UGizmos.DrawWireCapsule(bottomNew, topNew, Radius + skinWidth, Color.blue);
                UGizmos.DrawWireSphere(hitPos + _collisionInfo.RelevantOffset, Radius, Color.yellow);
                UGizmos.DrawArrow(hitPos, _collisionInfo.NearPoint, color, 1f, 0.05f);
                // UGizmos.DrawPoint(hitInfo.point - hitInfo.normal * skinWidth, 0.01f, Color.blue);
                UGizmos.DrawLine(hitInfo.point - hitInfo.normal * skinWidth,
                    hitInfo.point - hitInfo.normal * skinWidth - velocity.normalized * adjustedSkinWidth, Color.blue);
            }
            else
            {
                _collisionInfo.HasHit = false;
            }
        }

        private void OnDrawGizmos() => DrawPlayerGizmos(Color.green);

        private void DrawPlayerGizmos(Color color)
        {
            Gizmos.color = color;
            var bottom = GetBottomHemisphere(transform.position);
            var top = GetTopHemisphere(transform.position);
            Gizmos.DrawWireSphere(bottom, Radius);
            Gizmos.DrawWireSphere(top, Radius);
            Gizmos.DrawLine(bottom + Vector3.forward * Radius, top + Vector3.forward * Radius);
            Gizmos.DrawLine(bottom + Vector3.back * Radius, top + Vector3.back * Radius);
            Gizmos.DrawLine(bottom + Vector3.right * Radius, top + Vector3.right * Radius);
            Gizmos.DrawLine(bottom + Vector3.left * Radius, top + Vector3.left * Radius);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static Vector3 GetBottomHemisphere(Vector3 position) => position;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private Vector3 GetTopHemisphere(Vector3 position) => position + -down * height;

        private float Radius
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => radius;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static float PlaneDist(Vector3 point, Vector3 planeNormal, Vector3 planePosition)
        {
            return Vector3.Dot(point - planePosition, planeNormal);
        }

        private Vector3 ClosestPointOffset(Vector3 position, Vector3 point)
        {
            var bottom = GetBottomHemisphere(position);
            var top = GetTopHemisphere(position);

            var p1P2 = top - bottom;

            var t = Vector3.Dot(point - bottom, p1P2) / Vector3.Dot(p1P2, p1P2);
            t = Math.Clamp(t, 0, 1);

            return t * p1P2;
        }
    }
}
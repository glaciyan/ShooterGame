using System.Runtime.CompilerServices;
using Input;
using UGizmo;
using Unity.VisualScripting.FullSerializer.Internal.Converters;
using UnityEngine;
using UnityEngine.Serialization;
using Vector2 = UnityEngine.Vector2;
using Vector3 = UnityEngine.Vector3;

namespace Player
{
    [RequireComponent(typeof(PlayerInputHandler))]
    public class GameMovement : MonoBehaviour
    {
        [Header("Collision")]
        public float height = 1.8f;

        public float radius = 0.8f;

        [Tooltip(
            "Specifies a skin around the character within which contacts will be generated by the physics engine. Use it to avoid numerical precision issues.")]
        public float skinWidth = 0.008f;

        public LayerMask groundLayer;

        [Header("Gravity")]
        public float gravityForce = 0.35f;

        public Vector3 down = Vector3.down;

        [Header("Movement")]
        public float movementForce = 1.3f;

        public float groundFriction = 10f;

        [Header("Debug")]
        public Vector3 velocity = Vector3.zero;

        public Vector3 verticalVelocity = Vector3.zero;
        [FormerlySerializedAs("pushVelocity")] public Vector3 velocityOverride = Vector3.zero;
        [FormerlySerializedAs("usePush")] public bool useVelocityOverride = false;

        private CollisionInfo _collisionInfo;

        private const bool PlayerPhysicsDebug = true;
        private PlayerInputHandler _playerInputHandler;

        private void Awake()
        {
            _playerInputHandler = GetComponent<PlayerInputHandler>();
        }

        private void FixedUpdate()
        {
            // why is there a skin width https://chatgpt.com/share/26ad5379-b15d-4d69-82b4-e5a77b8eb873
            // https://lightbug14.gitbook.io/ccp/fundamentals/untitled/character-actor/stable-movement-features
            // https://docs.unity3d.com/Packages/com.unity.charactercontroller@1.1/manual/step-handling.html

            var dt = Time.fixedDeltaTime;
            var acceleration = Vector3.zero;

            // WASD movement
            acceleration += _playerInputHandler.RequestedMovementDirection * movementForce;

            // Ground friction
            acceleration -= velocity.normalized * (velocity.magnitude * groundFriction);

            // BUG: you can still build up velocity even when you have no degrees of freedom in that direction
            // Apply Horizontal velocity
            velocity += acceleration * dt;
            if (useVelocityOverride)
            {
                velocity = velocityOverride;
            }

            transform.position = CollideAndSlide(transform.position, ref velocity);
            // Debug.Log(Vector3.Dot(down, _collisionInfo.HitInfo.normal) + " " + casIter);
            UGizmos.DrawWireCapsule(GetBottomHemisphere(transform.position), GetTopHemisphere(transform.position),
                Radius + skinWidth, Color.gray);

            // Gravity
            // verticalVelocity += down * (gravityForce * dt);

            // Apply Vertical velocity
            // transform.position = CollideAndSlide(posNew, ref verticalVelocity);
        }

        private int casIter;

        private Vector3 CollideAndSlide(Vector3 pos, ref Vector3 vel)
        {
            var firstPlaneNormal = Vector3.zero;
            var dest = pos + vel;

            for (casIter = 0; casIter < 3; casIter++)
            {
                BodyCast(pos, vel);

                // no collisions
                if (!_collisionInfo.HasHit) return dest;

                pos += vel.normalized * _collisionInfo.ShortDistance;

                if (casIter == 0)
                {
                    // first plane hit
                    firstPlaneNormal = _collisionInfo.HitInfo.normal;
                    // vel = Vector3.ProjectOnPlane(_collisionInfo.RemainderVelocity, _collisionInfo.HitInfo.normal);
                    // dest = _collisionInfo.NearPoint + vel;
                    // BUG: dest is the bottom sphere, we need to get the closes point on the segment and use that somehow
                    dest -= (PlaneDist(dest, firstPlaneNormal, _collisionInfo.HitInfo.point) - (Radius + skinWidth)) *
                            firstPlaneNormal;
                    vel = dest - _collisionInfo.NearPoint;

                    if (PlayerPhysicsDebug)
                    {
                        // UGizmos.DrawPoint(dest, 0.01f, Color.blue);
                        // UGizmos.DrawPoint(_collisionInfo.NearPoint, 0.01f, Color.green);
                        // UGizmos.DrawWireCapsule(GetBottomHemisphere(_collisionInfo.NearPoint),
                        //     GetTopHemisphere(_collisionInfo.NearPoint), Radius, Color.gray);
                        // UGizmos.DrawPoint(dest, 0.01f, Color.red);
                        UGizmos.DrawLine(pos, pos + vel, Color.red);
                    }
                }
                else if (casIter == 1)
                {
                    // second plane hit
                    var crease = Vector3.Cross(firstPlaneNormal, _collisionInfo.HitInfo.normal).normalized;
                    var signedDistance = Vector3.Dot(_collisionInfo.RemainderVelocity, crease);
                    vel = signedDistance * crease;
                    dest = pos + vel;
                    UGizmos.DrawLine(pos, pos + vel, Color.blue);
                }
                else if (casIter == 2)
                {
                    vel = Vector3.zero;
                    pos = _collisionInfo.NearPoint;
                }
            }

            return pos;
        }

        private void BodyCast(Vector3 position, Vector3 vel)
        {
            var bottom = GetBottomHemisphere(position);
            var top = GetTopHemisphere(position);
            var magnitude = vel.magnitude;
            var direction = vel / magnitude;

            var hasHit = Physics.CapsuleCast(bottom, top, Radius, direction, out var hitInfo,
                magnitude + skinWidth, groundLayer, QueryTriggerInteraction.UseGlobal);

            var shortDistance = Mathf.Max(hitInfo.distance - skinWidth, 0f);
            var remainingDistance = magnitude - shortDistance;

            if (PlayerPhysicsDebug)
            {
                UGizmos.DrawRay(hitInfo.point, hitInfo.normal, Color.red);
            }

            if (hasHit)
            {
                _collisionInfo.HasHit = true;
                _collisionInfo.HitInfo = hitInfo;
                _collisionInfo.ShortDistance = shortDistance;
                _collisionInfo.RemainderVelocity = direction * remainingDistance;
                // BUG: NearPoint is not skinWidth away from the collision point
                _collisionInfo.NearPoint = position + direction * shortDistance;

                var color = casIter switch
                {
                    0 => Color.red,
                    1 => Color.blue,
                    _ => Color.green
                };
                UGizmos.DrawWireCapsule(bottom, top, Radius, color);
                var hitPos = position + direction * hitInfo.distance;
                var bottomNew = GetBottomHemisphere(hitPos);
                var topNew = GetTopHemisphere(hitPos);
                UGizmos.DrawWireCapsule(bottomNew, topNew, Radius, color);
                UGizmos.DrawArrow(hitPos, _collisionInfo.NearPoint, color, 1f, 0.05f);
                UGizmos.DrawWireSphere(_collisionInfo.NearPoint, Radius, Color.yellow);
            }
            else
            {
                _collisionInfo.HasHit = false;
            }
        }

        private void OnDrawGizmos() => DrawPlayerGizmos(Color.green);

        private void DrawPlayerGizmos(Color color)
        {
            Gizmos.color = color;
            var bottom = GetBottomHemisphere(transform.position);
            var top = GetTopHemisphere(transform.position);
            Gizmos.DrawWireSphere(bottom, Radius);
            Gizmos.DrawWireSphere(top, Radius);
            Gizmos.DrawLine(bottom + Vector3.forward * Radius, top + Vector3.forward * Radius);
            Gizmos.DrawLine(bottom + Vector3.back * Radius, top + Vector3.back * Radius);
            Gizmos.DrawLine(bottom + Vector3.right * Radius, top + Vector3.right * Radius);
            Gizmos.DrawLine(bottom + Vector3.left * Radius, top + Vector3.left * Radius);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static Vector3 GetBottomHemisphere(Vector3 position) => position;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private Vector3 GetTopHemisphere(Vector3 position) => position + -down * height;

        private float Radius
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => radius;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static float PlaneDist(Vector3 point, Vector3 planeNormal, Vector3 planePosition)
        {
            return Vector3.Dot(point, planeNormal) + -(planeNormal.x * planePosition.x +
                                                       planeNormal.y * planePosition.y +
                                                       planeNormal.z * planePosition.z);
        }
    }
}